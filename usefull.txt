-------------  0 - TL;DR ---------------

# PROD URL:
https://food-maniac.com/frozenbo


# Use app server (vps295100):
ssh lve@51.255.46.214
(not db server vps494554: 51.254.221.25)

# Connect on mongo (from app or db server):

# as admin from server:
mongo 51.254.221.25:27017/admin -u adminFrozen -p frozenPwd --authenticationDatabase admin --ssl --sslPEMKeyFile /etc/ssl/mongodb.pem --sslCAFile /etc/ssl/mongodb-cert.crt --sslAllowInvalidHostnames
# as admin from mac:
mongo 51.254.221.25:27017/admin -u adminFrozen -p frozenPwd --authenticationDatabase admin --ssl --sslPEMKeyFile /Users/lav/ssl/mongodb.pem --sslCAFile /Users/lav/ssl/mongodb-cert.crt --sslAllowInvalidHostnames

# as regular user (dev & prod) from server:
mongo 51.254.221.25:27017/frozen-dev -u frozen -p gem --authenticationDatabase frozen-dev --ssl --sslPEMKeyFile /etc/ssl/mongodb.pem --sslCAFile /etc/ssl/mongodb-cert.crt --sslAllowInvalidHostnames
mongo 51.254.221.25:27017/frozen -u frozen -p gem --authenticationDatabase frozen --ssl --sslPEMKeyFile /etc/ssl/mongodb.pem --sslCAFile /etc/ssl/mongodb-cert.crt --sslAllowInvalidHostnames

# as regular user (dev & prod) from mac:
mongo 51.254.221.25:27017/frozen-dev -u frozen -p gem --authenticationDatabase frozen-dev --ssl --sslPEMKeyFile /Users/lav/ssl/mongodb.pem --sslCAFile /Users/lav/ssl/mongodb-cert.crt --sslAllowInvalidHostnames
mongo 51.254.221.25:27017/frozen -u frozen -p gem --authenticationDatabase frozen --ssl --sslPEMKeyFile /Users/lav/ssl/mongodb.pem --sslCAFile /Users/lav/ssl/mongodb-cert.crt --sslAllowInvalidHostnames




---------------------------------------------------------------
                PROD utilities
---------------------------------------------------------------

# update from master:
cd workspace/frozen-bo/
chmod 755 ./prod_update_server.sh
./prod_update_server.sh 

# tail on logs:
pm2 log


# Front prod return
http-server ./build -p 5000 --cors



---------------------------------------------------------------
                manual actions with curl
---------------------------------------------------------------

Create user:
curl -X POST http://0.0.0.0:9000/users -i -d "email=test@example.com&password=123456&access_token=S9EqDPByR2z5mnCMaRFk7b552RWaFcnn"
curl -X POST http://51.254.221.25:8080/users -i -d "email=test@example.com&password=123456&access_token=S9EqDPByR2z5mnCMaRFk7b552RWaFcnn"
curl -X POST http://0.0.0.0:9000/users -i -d "role=admin&email=admin@example.com&password=123456&access_token=S9EqDPByR2z5mnCMaRFk7b552RWaFcnn"


Login user:
curl -X POST http://0.0.0.0:9000/auth -i -u 123@123.com:123456 -d "access_token=S9EqDPByR2z5mnCMaRFk7b552RWaFcnn"
curl -X POST http://0.0.0.0:9000/auth -i -u test@example.com:123456 -d "access_token=S9EqDPByR2z5mnCMaRFk7b552RWaFcnn"

See articles (not working):
curl -X POST http://0.0.0.0:9000/articles -i -d "title=Awesome Article&content=Yeah Baby&access_token=S9EqDPByR2z5mnCMaRFk7b552RWaFcnn"

View categ:
curl -X GET http://0.0.0.0:9000/categories -i -d "access_token=TOKEN"
curl -X GET http://0.0.0.0:9000/categories -i -d "access_token=TOKEN"



---------------------------------------------------------------
                Mongo
---------------------------------------------------------------

mongo
use admin
db.createUser({ user:"adminFrozen", pwd:"frozenPwd", roles:[{role:"root", db:"admin"}]})
exit

# Must create these users (admin & regular) for prod & dev dbs:
use admin
db.getUsers()
use frozen-dev
db.createUser({ user:"frozen", pwd:"gem", roles:["readWrite"] })
db.createUser({ user:"adminFrozen", pwd:"pwdRoot", roles: ["dbAdmin"]})
use frozen
db.createUser({ user:"frozen", pwd:"gem", roles:["readWrite"] })
db.createUser({ user:"adminFrozen", pwd:"pwdRoot", roles: ["dbAdmin"]})

# Remove home info from ALL users:
db.users.update({}, { $unset: { home:"", homeOrder:"" } }, {multi:true})

# Remove picture from all items:
db.items.update({}, { $unset: { picture:"" } }, {multi:true})

# Set remove flag on all items:
db.items.update({}, { $set: { removed:false } }, {multi:true})


---------------------------------------------------------------
                      JS / ES6 concepts
---------------------------------------------------------------


Promise chaining
----------------

        new Promise(function(resolve, reject) {

                setTimeout(() => resolve(1), 1000); // (*)

        }).then(function(result) { // (**)

                alert(result); // 1
                return result * 2;

        }).then(function(result) { // (***)

                alert(result); // 2
                return result * 2;

        }).then(function(result) {

                alert(result); // 4
                return result * 2;

        });

        The idea is that the result is passed through the chain of .then handlers.
        Here the flow is:
        - The initial promise resolves in 1 second (*),
        - Then the .then handler is called (**).
        - The value that it returns is passed to the next .then handler (***)
        …and so on.

        Normally, a value returned by a .then handler is immediately passed to the next handler. But there’s an exception.
        If the returned value is a promise, then the further execution is suspended until it settles. After that, the result of that promise is given to the next .then handler.
        For instance:

        new Promise(function(resolve, reject) {
                setTimeout(() => resolve(1), 1000);
        }).then(function(result) {
                alert(result); // 1
                return new Promise((resolve, reject) => { // (*)
                        setTimeout(() => resolve(result * 2), 1000);
                });
        }).then(function(result) { // (**)
                alert(result); // 2
                return new Promise((resolve, reject) => {
                        setTimeout(() => resolve(result * 2), 1000);
                });
        }).then(function(result) {
                alert(result); // 4
        });

        Here the first .then shows 1 returns new Promise(…) in the line (*). 
        After one second it resolves, and the result (the argument of resolve, here it’s result*2) is passed on to handler of the second .then in the line (**).
        It shows 2 and does the same thing.
        So the output is 1 → 2 → 4, but with 1 second delay between alert calls.
        Returning promises allows us to build chains of asynchronous actions.

Currying
--------

        A curried function is a function that takes multiple arguments one at a time. 
        Given a function with 3 parameters, the curried version will take one argument 
        and return a function that takes the next argument, which returns a function 
        that takes the third argument. 
        The last function returns the result of applying the function to all of its arguments.

        Ex:
        const add = a => b => a + b;
        const result = add(2)(3); // => 5



Side effects: Currying with promises
------------------------------------

        A common requirement when chaining promises is to perform some sort of side effect.
        In other words, execute an action that doesn’t result in data that is passed to the next step in the chain. 
        A side effect could be the need to send data to some other system, or simply just log some data.

        Ex:

        const sideEffect = fn => d => {
                fn(d)         // Execute the function placed in the 1st parenthesis
                return d;     // Pass the content of the 2nd parenthesis to .next without changing it
        };


        getReposForUser('ColinEberhardt')
        .then(sideEffect(repos => console.log(`repos returned ${repos.length}`)))
        .then(getRepoWithMostStargazers)
        .then(console.log)














---------------------------------------------------------------
                SSL with letsencrypt certbot
---------------------------------------------------------------

Did not do this:
  sudo apt install letsencrypt

Instead:

- Renew Letsencrypt certificate:
    - Ssh on the server
    - pm2 stop all
    - sudo systemctl stop nginx
    - /opt/letsencrypt/letsencrypt-auto renew
    - pm2 start all
    result (ceritificate) is there: /etc/letsencrypt/live/food-maniac.com/fullchain.pem 

- Creation process:
    - sudo git clone https://github.com/letsencrypt/letsencrypt /opt/letsencrypt
    - cd /opt/letsencrypt
    - sudo systemctl stop nginx
    - ./letsencrypt-auto certonly –standalone
    - sudo nano /etc/nginx/sites-enabled/default
    - sudo systemctl start nginx


- Use of certbot:
    - sudo add-apt-repository ppa:certbot/certbot
    - sudo apt-get update
    - sudo apt-get install python-certbot-nginx
    - list of existing certificates and expiration dates: sudo certbot certificates

    





---------------------------------------------------------------
        nginx (cohabitation foodManiac & frozenGem)
---------------------------------------------------------------


cd /etc/nginx/
more nginx.conf

        include /etc/nginx/conf.d/*.conf;
        include /etc/nginx/sites-enabled/*;

IMPORTANT NOTE ON ADDING PATHES TO THE SERVER: look comment in boServer.js


---------------------- Logs & debug ---------------

LOG file here: /var/log/nginx
sudo less /var/log/nginx/error.log


Test BoServer (NOT nginx) accessible locally, from server machine: curl localhost:8085/api



------------------  To restart nginx  ------------

/etc/init.d/nginx restart


------------------ File: sudo nano /etc/nginx/sites-available/default ------------------

# HTTP - redirect all requests to HTTPS:
server {
        listen 80;
        listen [::]:80 default_server ipv6only=on;
        return 301 https://$host$request_uri;
}

# HTTPS - proxy requests on to local Node.js app:
server {
        listen 443;
        server_name food-maniac.com;

        ssl on;
        # Use certificate and key provided by Let's Encrypt:
        ssl_certificate /etc/letsencrypt/live/food-maniac.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/food-maniac.com/privkey.pem;
        ssl_session_timeout 5m;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_prefer_server_ciphers on;
        ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH';






        # Pass requests for /frozenbo to localhost:8065:
        location /frozenbo/ {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-NginX-Proxy true;
                proxy_pass http://localhost:8065/;
                proxy_ssl_session_reuse off;
                proxy_set_header Host $http_host;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
        }

        # Pass requests for /frozengem to localhost:8060:
        location /frozengem/ {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-NginX-Proxy true;
                proxy_pass http://localhost:8060/;
                proxy_ssl_session_reuse off;
                proxy_set_header Host $http_host;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
        }



        




        # Pass requests for /api to localhost:8085:
        location /api/ {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-NginX-Proxy true;
                proxy_pass http://localhost:8085/api/;
                proxy_ssl_session_reuse off;
                proxy_set_header Host $http_host;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
        }

        # Pass requests for /util to localhost:8085:
        location /util/ {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-NginX-Proxy true;
                proxy_pass http://localhost:8085/util/;
                proxy_ssl_session_reuse off;
                proxy_set_header Host $http_host;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
        }

        # Pass requests for /socket.io to localhost:8085:
        location /socket.io/ {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-NginX-Proxy true;
                proxy_pass http://localhost:8085/socket.io/;
                proxy_ssl_session_reuse off;
                proxy_set_header Host $http_host;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
        }
        
        # Pass requests for /static to localhost:8085:
        location /static/ {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-NginX-Proxy true;
                proxy_pass http://localhost:8085/static/;
                proxy_ssl_session_reuse off;
                proxy_set_header Host $http_host;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
        }
        
        # Pass requests for /logs to localhost:8085:
        location /logs/ {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-NginX-Proxy true;
                proxy_pass http://localhost:8085/logs/;
                proxy_ssl_session_reuse off;
                proxy_set_header Host $http_host;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
        }

        # Pass requests for / to localhost:8080:
        location / {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-NginX-Proxy true;
                proxy_pass http://localhost:8080/;
                proxy_ssl_session_reuse off;
                proxy_set_header Host $http_host;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
        }

}



# HTTPS - proxy requests on to local Node.js app:
server {
        listen 443;
        server_name frozengem.com www.frozengem.com;

        ssl on;
        # Use certificate and key provided by Let's Encrypt:
        ssl_certificate /etc/letsencrypt/live/food-maniac.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/food-maniac.com/privkey.pem;
        ssl_session_timeout 5m;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_prefer_server_ciphers on;
        ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH';




        # Pass requests for /frozenbo to localhost:8065:
        location /frozenbo/ {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-NginX-Proxy true;
                proxy_pass http://localhost:8065/;
                proxy_ssl_session_reuse off;
                proxy_set_header Host $http_host;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
        }






        # Pass requests for / to localhost:8060:
        location / {
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-NginX-Proxy true;
                proxy_pass http://localhost:8060/;
                proxy_ssl_session_reuse off;
                proxy_set_header Host $http_host;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
        }


}
